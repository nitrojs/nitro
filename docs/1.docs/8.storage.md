---
icon: carbon:datastore
---

# KV Storage

> Nitro provides a built-in storage layer that can abstract filesystem or database or any other data source.

::warning
Nitro v3 Alpha docs are a work in progress â€” expect updates, rough edges, and occasional inaccuracies.
::

Nitro has built-in integration with [unstorage](https://unstorage.unjs.io) to provide a runtime agnostic persistent layer.

## Usage

To use the storage layer, you can use the `useStorage()` and call `get(key)` to retrieve an item and `set(key, value)` to set an item.

```ts
import { useStorage } from "nitro/runtime";

// Default storage is in memory
await useStorage().set("test:foo", { hello: "world" })
await useStorage().get("test:foo")

// You can use data storage to write data to default .data/kv directory
const dataStorage = useStorage("data")
await dataStorage.set("test", "works")
await dataStorage.get("data:test") // Value persists

// You can also specify the base in useStorage(base)
await useStorage("test").set("foo", { hello: "world" })

// You can use generics to define types
await useStorage<{ hello: string }>("test").get("foo")
await useStorage("test").get<{ hello: string }>("foo")
```

:read-more{to="https://unstorage.unjs.io"}

## Configuration

You can mount one or multiple custom storage drivers using the `storage` option.

The key is the mount point name, and the value is the driver name and configuration.

```ts [nitro.config.ts]
import { defineNitroConfig } from "nitro/config";

export default defineNitroConfig({
  storage: {
    redis: {
      driver: "redis",
      /* redis connector options */
    }
  }
})
```

Then, you can use the redis storage using the `useStorage("redis")` function.

::read-more{to="https://unstorage.unjs.io/"}
You can find the driver list on [unstorage documentation](https://unstorage.unjs.io/) with their configuration.
::

## Development-only storage

By default, Nitro will mount the project directory and some other directories using the filesystem driver in development.

```js
// Access to project root dir
const rootStorage = useStorage('root')

// Access to project src dir (same as root by default)
const srcStorage = useStorage('src')

// Access to server cache dir
const cacheStorage = useStorage('cache')

// Access to the temp build dir
const buildStorage = useStorage('build')
```

> [!TIP]
> You also can use the `devStorage` key to overwrite the storage configuration during development. This is very useful when you use a database in production and want to use the filesystem in development.

In order to use the `devStorage` key, you need to use the `nitro dev` command and the key in the `storage` option must be the same as the production one.

```ts [nitro.config.ts]
import { defineNitroConfig } from "nitro/config";

export default defineNitroConfig({
  // Production
  storage: {
    default: {
      driver: 'redis',
      /* redis connector options */
    }
  },
  // Development
  devStorage: {
    default: {
      driver: 'fs',
      base: './data/kv'
    }
  }
})
```

## Runtime configuration

In scenarios where the mount point configuration is not known until runtime, Nitro can dynamically add mount points during startup using [plugins](/guide/plugins).

```ts [plugins/storage.ts]
import { defineNitroPlugin, useStorage } from "nitro/runtime";
import redisDriver from "unstorage/drivers/redis";

export default defineNitroPlugin(() => {
  const storage = useStorage()

  // Dynamically pass in credentials from runtime configuration, or other sources
  const driver = redisDriver({
    base: "redis",
    host: process.env.REDIS_HOST,
    port: process.env.REDIS_PORT,
    /* other redis connector options */
  })

  // Mount driver
  storage.mount("redis", driver)
})
```

::warning
This is a temporary workaround, with a better solution coming in the future! Keep a lookout on the GitHub issue [here](https://github.com/nitrojs/nitro/issues/1161#issuecomment-1511444675).
::

---
icon: ri:layout-masonry-line
navigation:
  title: Renderer
---

# Nitro Renderer

> Use a renderer to handle all unmatched routes with custom HTML or a templating system.

The renderer is a special handler in Nitro that catches all routes that don't match any specific API or route handler. It's commonly used for server-side rendering (SSR), serving single-page applications (SPAs), or creating custom HTML responses.

## HTML template

### Auto-detected `index.html`

By default, Nitro follows the [Vite](https://vite.dev/) convention and automatically looks for an `index.html` file in your project root or scan directories.

If found, Nitro will use it as the renderer template and serve it for all unmatched routes.

::code-group
```html [index.html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Vite + Nitro App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```
```ts [routes/api/hello.ts]
import { defineHandler } from "nitro/deps/h3";

export default defineHandler((event) => {
  return { hello: "API" };
});
```
::

::tip
When `index.html` is detected, Nitro will automatically log in the terminal: `Using index.html as renderer template.`
::

With this setup:
- `/api/hello` → Handled by your API routes
- `/about`, `/contact`, etc. → Served with `index.html`

### Custom HTML file

You can specify a custom HTML template file using the `renderer.template` option in your Nitro configuration.

::code-group
```ts [nitro.config.ts]
export default defineNitroConfig({
  renderer: {
    template: './app.html'
  }
})
```

```html [app.html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Custom Template</title>
  </head>
  <body>
    <div id="root">Loading...</div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```
::

### Templating engine

Nitro uses the [rendu](https://github.com/h3js/rendu) templating library, which provides a simple and powerful way to create dynamic HTML templates with JavaScript expressions.

You can use special delimiters to inject dynamic content:
- `{{ content }}` to output HTML-escaped content
- `{{{ content }}}` or `<?= expression ?>` to output raw (unescaped) content
- `<? ... ?>` for JavaScript control flow

It also exposes global variables:
- `$REQUEST`: The incoming Request object
- `$METHOD`: HTTP method (GET, POST, etc.)
- `$URL`: Request URL object
- `$HEADERS`: Request headers
- `$RESPONSE`: Response configuration object
- `$COOKIES`: Read-only object containing request cookies

```html [index.html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Dynamic template</title>
  </head>
  <body>
    <h1>Hello {{ $REQUEST.url }}</h1>
  </body>
</html>
```

:read-more{to="https://github.com/h3js/rendu" title="Rendu Documentation"}

## Custom renderer handler

For more complex scenarios, you can create a custom renderer handler that programmatically generates responses.

Create a renderer file and use `defineRenderHandler` to define your custom rendering logic:

```ts [renderer.ts]
import { defineRenderHandler } from "nitro/runtime";

export default defineRenderHandler((event) => {
  return {
    body: `<!DOCTYPE html>
      <html>
        <head>
          <title>Custom Renderer</title>
        </head>
        <body>
          <h1>Hello from custom renderer!</h1>
          <p>Current path: ${event.path}</p>
        </body>
      </html>`,
    headers: {
      'content-type': 'text/html; charset=utf-8'
    }
  }
})
```

Then, specify the renderer entry in the Nitro config:

::code-group
```ts [vite.config.mjs]
import { defineConfig } from 'vite'
import { nitro } from 'nitro/vite'

export default defineConfig({
  plugins: [nitro()],
  nitro: {
    renderer: {
      entry: './renderer.ts'
    }
  }
})
```
```ts [nitro.config.ts]
export default defineNitroConfig({
  renderer: {
    entry: './renderer.ts'
  }
})
```
::

## Renderer hooks

You can use [Nitro plugins](/docs/plugins) to hook into the rendering lifecycle and modify the response.

### `render:before`

Called before the render handler executes. You can use this to modify the context or provide a custom response:

```ts [plugins/render-hooks.ts]
import { defineNitroPlugin } from "nitro/runtime";

export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:before', (ctx) => {
    // You can modify the context
    console.log('Rendering:', ctx.event.path)

    // Or provide a custom response to skip the render handler
    if (ctx.event.path === '/custom') {
      ctx.response = {
        body: '<h1>Custom response!</h1>',
        headers: { 'content-type': 'text/html' }
      }
    }
  })
})
```

### `render:response`

Called after the render handler executes, before sending the response. You can use this to modify the response:

```ts [plugins/renderer.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:response', (response, ctx) => {
    // Add custom headers
    response.headers = response.headers || {}
    response.headers['x-rendered-at'] = new Date().toISOString()

    // Modify the HTML
    if (typeof response.body === 'string') {
      response.body = response.body.replace(
        '</body>',
        '<script>console.log("Injected!")</script></body>'
      )
    }
  })
})
```

::note
Renderer hooks only work for routes handled by the renderer. They won't be called for API routes or other specific handlers.
::

## Renderer priority

The renderer always acts as a catch-all route (`/**`) and has the **lowest priority**. This means:

1. Specific API routes are matched first (e.g., `/api/users`)
2. Specific server routes are matched next (e.g., `/about`)
3. The renderer catches everything else

```md
server/
  api/
    users.ts        → /api/users (matched first)
  routes/
    about.ts        → /about (matched second)
renderer.ts         → /** (catches all other routes)
```

::warning
If you define a catch-all route (`[...].ts`) in your routes, Nitro will warn you that the renderer will override it. Use more specific routes or different HTTP methods to avoid conflicts.
::

:read-more{to="/docs/architecture#request-lifecycle" title="Architecture > Request lifecycle"}

## Use Cases

### Single-Page Application (SPA)

Serve your SPA's `index.html` for all routes to enable client-side routing:

> [!TIP]
> This is the default behavior of Nitro when used with Vite.

### Server-Side Rendering (SSR)

Full-stack frameworks like [Nuxt](https://nuxt.com) use the renderer to handle server-side rendering:

```ts [renderer.ts]
export default defineRenderHandler(async (event) => {
  // Render the Vue app based on the current route
  const html = await renderApp(event.path)

  return {
    body: html,
    headers: { 'content-type': 'text/html' }
  }
})
```

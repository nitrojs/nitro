---
icon: ri:plug-line
---

# Plugins

> Use plugins to extend Nitro's runtime behavior.

::warning
Nitro v3 Alpha docs are a work in progress â€” expect updates, rough edges, and occasional inaccuracies.
::

Nitro plugins will be **executed once** during server startup in order to allow extending Nitro's runtime behavior.
They receive `nitroApp` context, which can be used to hook into Nitro lifecycle events.

Plugins are auto-registered from `plugins/` directory and run synchronously (by order of file name) on the first Nitro initialization.


**Example:**

```ts [plugins/test.ts]
import { definePlugin } from "nitro";

export default definePlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

If you have plugins in another directory, you can use the `plugins` option:

```ts [nitro.config.ts]
import { defineNitroConfig } from "nitro/config";

export default defineNitroConfig({
  plugins: ['my-plugins/hello.ts']
})
```

## Nitro runtime hooks

You can use Nitro [hooks](https://github.com/unjs/hookable) to extend the default runtime behaviour of Nitro by registering custom (async or sync) functions to the lifecycle events within plugins.

**Example:**

```ts
import { definePlugin } from "nitro";

export default definePlugin((nitro) => {
  nitro.hooks.hook("close", async () => {
    // Will run when nitro is being closed
  });
})
```

### Available hooks

- `"request", (event) => {}` - Called when a request is received.
- `"error", (error, { event? }) => {}` - Called when an error is captured.
- `"response", (response, event) => {}` - Called when a response is sent.
- `"close", () => {}` - Called when the server receives a shutdown signal (`SIGTERM` or `SIGINT`).

## Examples

### Capturing errors

You can use plugins to capture all application errors.

```ts
import { definePlugin } from "nitro";

export default definePlugin((nitro) => {
  nitro.hooks.hook("error", async (error, { event }) => {
    console.error(`${event.path} Application error:`, error)
  });
})
```

### Graceful shutdown

When the server receives a shutdown signal (`SIGTERM` or `SIGINT`), the `close` hook is called, allowing plugins to run async cleanup before the process exits. This is useful for flushing telemetry, draining database connections, stopping job queues, and other teardown tasks.

```ts
import { definePlugin } from "nitro";

export default definePlugin((nitro) => {
  nitro.hooks.hook("close", async () => {
    await flushTelemetry();
    await db.close();
  });
})
```

### Request and response lifecycle

You can use plugins to register a hook that can run on request lifecycle:

```ts
import { definePlugin } from "nitro";

export default definePlugin((nitroApp) => {
  nitroApp.hooks.hook("request", (req) => {
    console.log("on request", req.url);
  });
});
```

---
icon: i-lucide-compass
---

# Introduction

> Welcome to Nitro: Progressive, Compatible, and Production-Ready.

Nitro is a full-stack framework that can run as a standalone backend server or extend your Vite application with a production-ready server.

## Extend your Vite application with...

### Production-ready server

As a bundler, Vite's main purpose is to build frontend applications. So it only provides a fast dev server to transform and serve resources with HMR.

By extending your Vite application with Nitro, you can easily have a production-ready server. Running `vite build` builds both your backend and frontend code into an optimized `.output/` folder.

### API Routes

When creating an SPA, you often need to add API routesâ€”whether to bypass CORS, call services with an API token, or implement your own backend logic.

Nitro lets you create server and API routes inside the `routes/` directory of your project.

### Server-Side Rendering

Having a server also unlocks server-side rendering. You can render HTML with your favorite templating engine, or use component libraries such as React, Vue, or Svelte directly on the server. You can even go full universal rendering with client-side hydration.

Nitro provides the foundation and a progressive approach to reach your goals.

## Deploy to anywhere

Nitro has excellent cross-platform compatibility. Its output is compatible not only with Node.js, Bun, and Deno, but also with many hosting platforms without any configuration.

This means you can deploy your application to Cloudflare Workers, Netlify, Vercel, and more, without changing a single line of code, while taking advantage of platform features like ESR, ISR, and SWR.

## Integrate with other frameworks

You can go further and take control of the entire server entry by creating a `server.ts` file. With its high-level and runtime-agnostic approach, Nitro allows you to use any HTTP library, such as [Elysia](https://elysiajs.com/), [Express](https://expressjs.com/), [h3](https://h3.dev/) or [Hono](https://hono.dev/).

## Optimal Performance

By combining code-splitting with compiled routes, Nitro removes the need for a runtime router, leaving only minimal compiled logic.

This makes it ideal for serverless hosting, since boot-up time is nearly 0ms regardless of project size and only the code required to handle the incoming request is loaded and executed.

## Built-in functions

### KV Storage

Server data storage is often needed, and Nitro includes a runtime-agnostic key-value storage layer out of the box.

It uses in-memory storage by default. You can connect more than 20 different drivers (FS, Redis, S3, etc.), attach them to different namespaces, and swap them without changing your code.

### Cache

Caching is a key part of any web server, which is why Nitro supports caching for both server routes and server functions, backed directly by the server storage (via the `cache` namespace).

### SQL Database

When key-value storage isn' t enough, Nitro also includes a built-in SQL database.

It defaults to SQLite and allows you to connect to and query more than 10 databases (Postgres, MySQL, PGLite, etc.) using the same API.

## Build your meta-framework with Nitro

Nitro can be used as the foundation for building a meta-framework. Popular frameworks such as Nuxt, SolidStart and TanStack Start fully or partially leverage Nitro.

## Try it now

Ready to give it a try? Jump into the [quick start](/docs/quick-start).
